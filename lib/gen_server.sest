module Prim = struct

  module GenServer = struct

    signature Behaviour = sig

      type init_arg :: 0

      type request :: 0
        /* temporary; should be a unary GADT */

      type response :: 0
        /* temporary; should be a unary GADT  */

      type cast_message :: 0

      type state :: 0

      val init : fun(init_arg) -> state

      val handle_call<$a> : fun(request, pid<$a>, state) -> (response, state)

      val handle_cast : fun(cast_message, state) -> state

    end

    module Make = fun(Callback : Behaviour) -> struct

      type request = Callback.request

      type response = Callback.response

      type cast_message = Callback.cast_message

      type gen_server = unit

      type proc = pid<gen_server>

      let init_impl(arg : Callback.init_arg) =
        Callback.init(arg)

      let init<$a> : $a = external 1 ```
        init(Args) ->
            State = ?MODULE:init_impl(Args),
            {ok, State}.
      ```

      let handle_call_impl<$a>(req : Callback.request, pid : pid<$a>, state : Callback.state) =
        Callback.handle_call(req, pid, state)

      let handle_call<$a> : $a = external 3 ```
        handle_call(Msg, From, State0) ->
            {Pid, _} = From,
            {Response, State1} = ?MODULE:handle_call_impl(Msg, Pid, State0),
            {reply, Response, State1}.
      ```

      let handle_cast_impl(msg : Callback.cast_message, state : Callback.state) =
        Callback.handle_cast(msg, state)

      let handle_cast<$a> : $a = external 2 ```
        handle_cast(Msg, State0) ->
            State1 = ?MODULE:handle_cast_impl(Msg, State0),
            {noreply, State1}.
      ```

      let call<$a> : fun(proc, request) -> [$a]response = external 2 ```
        call(Pid, Msg) ->
            fun() -> gen_server:call(Pid, Msg) end.
      ```

      let cast<$a> : fun(proc, cast_message) -> [$a]unit = external 2 ```
        cast(Pid, Msg) ->
            fun() -> gen_server:cast(Pid, Msg) end.
      ```

      let start_link<$a> : fun(Callback.init_arg) -> [$a]proc = external 1 ```
        start_link(Args) ->
            fun() ->
                case gen_server:start_link(?MODULE, Args, []) of
                    {ok, Pid} -> Pid;
                    Other     -> erlang:error({unsupported, Other})
                end
            end.
      ```

    end

  end

  module Example = struct

    type request_impl =
      | GetNumber
      | GetName

    type response_impl =
      | Number(int)
      | Name(binary)

    type cast_message_impl =
      | SetNumber(int)

    module C = struct

      type init_arg =
        (int, binary)

      type request = request_impl
      type response = response_impl
      type cast_message = cast_message_impl

      type state =
        (int, binary)

      let init(state) =
        let _ = print_debug(<<"init">>) in
        let _ = print_debug(state) in
        state

      let handle_call(req, pid, state) =
        let (n, s) = state in
        case req of
        | GetNumber -> (Number(n), state)
        | GetName   -> (Name(s), state)
        end

     let handle_cast(msg, state) =
       let _ = print_debug((<<"handle_cast, received:">>, msg)) in
       let (_, s) = state in
       case msg of
       | SetNumber(m) -> (m, s)
       end

    end

    include GenServer.Make(C)

    let set_number<$a>(pid : proc, m : int) : [$a]unit =
      cast(pid, SetNumber(m))

    let get_number<$a>(pid : proc) : [$a]int =
      do res <- call(pid, GetNumber) in
      case res of
      | Number(n) -> return(n)
      | _         -> return(0)
      end

  end

  module Main = struct

    letrec loop(t, pid) =
      if t <= 0 then
        return(())
      else
        do n <- Example.get_number(pid) in
        let _ = print_debug((t, n)) in
        loop(t - 1, pid)

    let main() =
      do pid <- Example.start_link((57, <<"Sample Store">>)) in
      do x <- Example.get_number(pid) in
      let _ = print_debug((<<"first get">>, x)) in
      do Example.set_number(pid, 42) in
      loop(10, pid)

  end

end
