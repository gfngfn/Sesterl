import Option
import List
import RawMap
import ServerUtil
import GenServer
import Supervisor

module Stdlib :> sig

  type name =
    | Local(binary)
    | Global(binary)

  module Option : sig
    val get<$a> : fun(option<$a>, -default $a) -> $a
    val get_or_invoke<$a> : fun(option<$a>, -default fun() -> $a) -> $a
    val map<$a, $b> : fun(fun($a) -> $b, option<$a>) -> option<$b>
    val bind<$a, $b> : fun(option<$a>, fun($a) -> option<$b>) -> option<$b>
  end

  module List : sig
    val map<$a, $b> : fun(fun($a) -> $b, list<$a>) -> list<$b>
    val filter<$a> : fun(fun($a) -> bool, list<$a>) -> list<$a>
    val filter_map<$a, $b> : fun(fun($a) -> option<$b>, list<$a>) -> list<$b>
    val for_each<$msg, $a> : fun(fun($a) -> [$msg]unit, list<$a>) -> [$msg]unit
    val foldl<$a, $b> : fun(fun($b, $a) -> $b, $b, list<$a>) -> $b
    val foldr<$a, $b> : fun(fun($a, $b) -> $b, $b, list<$a>) -> $b
    val all<$a> : fun(fun($a) -> bool, list<$a>) -> bool
    val any<$a> : fun(fun($a) -> bool, list<$a>) -> bool
    val append<$a> : fun(list<$a>, list<$a>) -> list<$a>
    val reverse<$a> : fun(list<$a>) -> list<$a>
  end

  module RawMap : sig
    type t :: (o, o) -> o
    val new<$k, $v> : fun() -> t<$k, $v>
    val put<$k, $v> : fun($k, $v, t<$k, $v>) -> t<$k, $v>
    val find<$k, $v> : fun($k, t<$k, $v>) -> option<$v>
    val remove<$k, $v> : fun($k, t<$k, $v>) -> t<$k, $v>
    val to_list<$k, $v> : fun(t<$k, $v>) -> list<{$k, $v}>
    val merge<$k, $v> : fun(t<$k, $v>, t<$k, $v>) -> t<$k, $v>
    val map<$k, $v1, $v2> : fun(fun($v1) -> $v2, t<$k, $v1>) -> t<$k, $v2>
  end

  module GenServer : sig

    type initialized :: (o) -> o

    val init_ok<$msg, $state> : fun($state) -> [$msg]initialized<$state>

    val init_fail<$msg, $state> : fun() -> [$msg]initialized<$state>

    type reply :: (o, o, o) -> o

    val reply<$msg, $response, $state> :
      fun($response, $state) -> [$msg]reply<$msg, $response, $state>

    val reply_fast<$msg, $response, $state> :
      fun($response, -rest fun() -> [$msg]$state) -> [$msg]reply<$msg, $response, $state>

    type no_reply :: (o) -> o

    val no_reply<$msg, $state> : fun($state) -> [$msg]no_reply<$state>

    signature Behaviour = sig
      type init_arg :: o
      type request :: o  /* temporary; should be a unary GADT */
      type response :: o  /* temporary; should be a unary GADT  */
      type cast_message :: o
      type info :: o
      type state :: o
      val init : fun(init_arg) -> [info]initialized<state>
      val handle_call<$a> : fun(request, pid<$a>, state) -> [info]reply<info, response, state>
      val handle_cast : fun(cast_message, state) -> [info]no_reply<state>
      val handle_info : fun(info, state) -> [info]no_reply<state>
      val terminate : fun(state) -> [info]unit
    end

    module Make : fun(Callback : Behaviour) -> sig
      type proc :: o
      val as_pid : fun(proc) -> pid<Callback.info>
      val from_pid : fun(pid<Callback.info>) -> proc
      val call<$a> : fun(proc, Callback.request, ?timeout int) -> [$a]Callback.response
      val cast<$a> : fun(proc, Callback.cast_message) -> [$a]unit
      val send_info<$a> : fun(proc, Callback.info) -> [$a]unit
      val start_link<$a> : fun(Callback.init_arg) -> [$a]option<proc>
      val start_link_name<$a> : fun(Callback.init_arg, -name name) -> [$a]option<{bool, proc}>
      val where_is<$a> : fun(binary) -> [$a]option<proc>
      val stop<$a> : fun(proc) -> [$a]unit
    end
  end

  module Supervisor : sig
    type restart = Permanent | Transient | Temporary
    type shutdown = BrutalKill | Timeout(int) | Infinity
    type worker = Worker | Supervisor

    module Static : sig
      type child_proc :: o
      val make_child_proc<$a, $b, $c> : fun(fun() -> [$b]option<pid<$a>>) -> [$c]child_proc
      type child_spec :: (o, o) -> o
      val make_child_spec<$msg, $id> :
        fun(
          -id       $id,
          -start    frozen<unit, $msg, child_proc>,
          ?restart  restart,
          ?shutdown shutdown,
          ?type     worker,
        ) -> child_spec<$msg, $id>
      type strategy = OneForAll | OneForOne | RestForOne
      type sup_flags :: o
      val make_sup_flags : fun(?strategy strategy, ?intensity int, ?period int) -> sup_flags
      type initialized :: (o, o) -> o
      val init_ok<$msg, $id> : fun(sup_flags, list<child_spec<$msg, $id>>) -> [$msg]initialized<$msg, $id>
      val init_fail<$msg, $id> : fun() -> [$msg]initialized<$msg, $id>

      signature Behaviour = sig
        type child_id :: o
        type init_arg :: o
        type info :: o
        val init : fun(init_arg) -> [info]initialized<info, child_id>
      end

      module Make : fun(Callback : Behaviour) -> sig
        type proc :: o
        val as_pid : fun(proc) -> pid<Callback.info>
        val from_pid : fun(pid<Callback.info>) -> proc
        val start_link<$a> : fun(Callback.init_arg) -> [$a]option<proc>
        val start_link_name<$a> : fun(Callback.init_arg, -name name) -> [$a]option<{bool, proc}>
        val where_is<$a> : fun(binary) -> [$a]option<proc>
      end
    end

    module Dynamic : sig
      type child_proc :: (o) -> o
      val make_child_proc<$b, $child_msg, $c> : fun(fun() -> [$b]option<pid<$child_msg>>) -> [$c]child_proc<$child_msg>
      type child_spec :: (o, o, o) -> o
      val make_child_spec<$msg, $arg, $child_msg> :
        fun(
          -start    frozen<{$arg}, $msg, child_proc<$child_msg>>,
          ?restart  restart,
          ?shutdown shutdown,
          ?type     worker,
        ) -> child_spec<$msg, $arg, $child_msg>
      type sup_flags :: o
      val make_sup_flags : fun(?intensity int, ?period int) -> sup_flags
      type initialized :: (o, o, o) -> o
      val init_ok<$msg, $arg, $child_msg> : fun(sup_flags, child_spec<$msg, $arg, $child_msg>) -> [$msg]initialized<$msg, $arg, $child_msg>
      val init_fail<$msg, $arg, $child_msg> : fun() -> [$msg]initialized<$msg, $arg, $child_msg>

      signature Behaviour = sig
        type init_arg :: o
        type start_arg :: o
        type info :: o
        type child_info :: o
        val init : fun(init_arg) -> [info]initialized<info, start_arg, child_info>
      end

      module Make : fun(Callback : Behaviour) -> sig
        type proc :: o
        val as_pid : fun(proc) -> pid<Callback.info>
        val from_pid : fun(pid<Callback.info>) -> proc
        val start_link<$a> : fun(Callback.init_arg) -> [$a]option<proc>
        val start_link_name<$a> : fun(Callback.init_arg, -name name) -> [$a]option<{bool, proc}>
        val where_is<$a> : fun(binary) -> [$a]option<proc>
        val start_child<$a> : fun(proc, Callback.start_arg) -> [$a]option<pid<Callback.child_info>>
      end
    end
  end

end = struct
  module Option = Option
  module List = List
  module RawMap = RawMap
  include ServerUtil
  module GenServer = GenServer
  module Supervisor = Supervisor
end
