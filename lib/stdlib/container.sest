module Stdlib :> sig

  module List : sig
    val map<$a, $b> : fun(fun($a) -> $b, list<$a>) -> list<$b>
    val foldl<$a, $b> : fun(fun($b, $a) -> $b, $b, list<$a>) -> $b
    val foldr<$a, $b> : fun(fun($a, $b) -> $b, $b, list<$a>) -> $b
    val all<$a> : fun(fun($a) -> bool, list<$a>) -> bool
    val any<$a> : fun(fun($a) -> bool, list<$a>) -> bool
    val append<$a> : fun(list<$a>, list<$a>) -> list<$a>
    val reverse<$a> : fun(list<$a>) -> list<$a>
  end

  module GenServer : sig
    signature Behaviour = sig
      type init_arg :: o
      type request :: o  /* temporary; should be a unary GADT */
      type response :: o  /* temporary; should be a unary GADT  */
      type cast_message :: o
      type info :: o
      type state :: o
      val init : fun(init_arg) -> option<state>
      val handle_call<$a> : fun(request, pid<$a>, state) -> (response, state)
      val handle_cast : fun(cast_message, state) -> state
      val handle_info : fun(info, state) -> state
      val terminate : fun(state) -> unit
    end

    module Make : fun(Callback : Behaviour) -> sig
      type proc :: o
      val call<$a> : fun(proc, Callback.request, ?timeout int) -> [$a]Callback.response
      val cast<$a> : fun(proc, Callback.cast_message) -> [$a]unit
      val send_info<$a> : fun(proc, Callback.info) -> [$a]unit
      val start_link<$a> : fun(Callback.init_arg) -> [$a]option<proc>
      val stop<$a> : fun(proc) -> [$a]unit
    end
  end

  module Supervisor : sig
    module Static : sig
      type strategy :: o /* =
        | OneForAll
        | OneForOne
        | RestForOne */
      type sup_flags :: o
      val make_sup_flags :
        fun(
          ?strategy  strategy,
          ?intensity int,
          ?period    int,
        ) -> sup_flags
      type child_proc :: o
      val make_child_proc<$a> : fun(pid<$a>) -> child_proc
      type restart :: o /* =
        | Permanent
        | Transient
        | Temporary */
      type shutdown :: o /* =
        | BrutalKill
        | Timeout(int)
        | Infinity */
      type worker :: o /* =
        | Worker
        | Supervisor */
      type child_spec :: (o) -> o
      val make_child_spec<$a> :
        fun(
          -id       $a,
          -start    frozen<child_proc>,
          ?restart  restart,
          ?shutdown shutdown,
          ?type     worker,
        ) -> child_spec<$a>

      signature Behaviour = sig
        type child_id :: o
        type init_arg :: o
        val init : fun(init_arg) -> option<(sup_flags, list<child_spec<child_id>>)>
      end

      module Make : fun(Callback : Behaviour) -> sig
        type proc :: o
        val start_link<$a> : fun(Callback.init_arg) -> [$a]option<proc>
      end
    end
  end

end = struct
  module List = List
  module GenServer = GenServer
  module Supervisor = Supervisor
end
