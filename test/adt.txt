
letrec foldl(f, i, l) =
  case l of
  | []      -> i
  | x :: xs -> foldl(f, f(i, x), xs)
  end

let reverse_map(f, xs) =
  foldl(fun(acc, x) -> f(x) :: acc, [], xs)

let sum(ns) =
  foldl(fun(m, n) -> m + n, 0, ns)

type tree($a) =
  | Node($a, list(tree($a)))

let leaf(x) =
  Node(x, [])

letrec tree_size(tr) =
  let Node(_, children) = tr in
  case children of
  | []     -> 1
  | _ :: _ -> 1 + sum(reverse_map(tree_size, children))
  end

let main() =
  let tr =
    Node(3,
      Node(1,
        leaf(4) ::
        Node(1,
          leaf(5) ::
          leaf(9) :: []
        ) ::
        leaf(2) :: []
      ) :: []
    )
  in
  tree_size(tr)
