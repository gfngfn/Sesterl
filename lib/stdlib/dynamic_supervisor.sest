require ServerUtil
require SupervisorCommon

module DynamicSupervisor = struct

  include SupervisorCommon

  type child_spec<$msg, $arg, $child> = {
    start    : frozen<{$arg}, [$msg]option<$child>>,
    restart  : restart,
    shutdown : shutdown,
    typ      : worker,
  }

  let make_child_spec<$msg, $arg, $child>(
    -start    start : frozen<{$arg}, [$msg]option<$child>>,
    ?restart  restart = Permanent,
    ?shutdown shutdown_opt,
    ?type     typ = Worker,
  ) : child_spec<$msg, $arg, $child> =
    let shutdown =
      case {shutdown_opt, typ} of
      | {Some(shutdown), _} -> shutdown
      | {None, Worker}      -> Timeout(5000)
      | {None, Supervisor}  -> Infinity
      end
    in
    {
      start    = start,
      restart  = restart,
      shutdown = shutdown,
      typ      = typ,
    }

  type sup_flags = {
    intensity : int,
    period    : int,
  }

  let make_sup_flags(?intensity intensity = 1, ?period period = 5) : sup_flags =
    { intensity = intensity, period = period }

  type initialized<$msg, $arg, $child> = option<{sup_flags, child_spec<$msg, $arg, $child>}>

  let init_ok(sup_flags, child_spec) =
    return(Some({sup_flags, child_spec}))

  let init_fail() =
    return(None)

  signature Behaviour = sig
    type info :: o
    type init_arg :: o
    type start_arg :: o
    type child :: o
    val init : fun(init_arg) -> [info]initialized<info, start_arg, child>
  end

  module Make = fun(Callback : Behaviour) -> struct

    type proc = ProcDummy

    let init_impl(init_arg) =
      Callback.init(init_arg)

    let init<$a> : $a = external 1 ```
      init(InitArg) ->
          InitF = init_impl(InitArg),
          Ret =
          case InitF() of
              none ->
                  ignore;

              {some, {SupFlagsImpl, ChildSpecImpl}} ->
                  #{
                      intensity := Intensity,
                      period    := Period
                  } = SupFlagsImpl,
                  SupFlags = #{
                      strategy  => simple_one_for_one,
                      intensity => erlang:max(Intensity, 0),
                      period    => erlang:max(Period, 1)
                  },
                  #{
                      start    := StartFunc,
                      restart  := Restart,
                      shutdown := ShutdownImpl,
                      typ      := Worker
                  } = ChildSpecImpl,
                  Shutdown =
                      case ShutdownImpl of
                          brutal_kill  -> brutal_kill;
                          {timeout, N} -> max(N, 0);
                          infinity     -> infinity
                      end,
                  ChildSpec = #{
                      id       => ?MODULE,
                      start    => StartFunc,
                      restart  => Restart,
                      shutdown => Shutdown,
                      type     => Worker
                  },
                  {ok, {SupFlags, [ChildSpec]}}
          end.
    ```

    let as_pid : fun(proc) -> pid<Callback.info> = external 1 ```
      as_pid(Pid) -> Pid.
    ```

    let start_link<$a> : fun(Callback.init_arg) -> [$a]option<proc> = external 1 ```
      start_link(InitArg) ->
          fun() ->
              case supervisor:start_link(?MODULE, InitArg) of
                  {ok, SupPid} when is_pid(SupPid) -> {some, SupPid};
                  _                                -> none
              end
          end.
            % thunk
    ```

    let start_link_name<$a> : fun(Callback.init_arg, -name ServerUtil.name) -> [$a]option<{bool, proc}> = external 2 ```
      start_link_name(InitArg, NameImpl) ->
          Name =
              case NameImpl of
                  {local, Bin}  -> {local, erlang:binary_to_atom(Bin, utf8)};
                  {global, Bin} -> {global, erlang:binary_to_atom(Bin, utf8)}
              end,
          fun() ->
              StartRet = supervisor:start_link(Name, ?MODULE, InitArg),
              case StartRet of
                  {ok, SupPid} when is_pid(SupPid)   -> {some, {true, SupPid}};
                  {error, {already_started, SupPid}} -> {some, {false, SupPid}};
                  _                                  -> none
              end
          end.
            % thunk
    ```

    let where_is<$a> : fun(binary) -> [$a]option<proc> = external 1 ```
      where_is(NameBin) ->
          NameAtom = erlang:binary_to_atom(NameBin, utf8),
          fun() ->
              case erlang:whereis(NameAtom) of
                  Pid when is_pid(Pid) -> {some, Pid};
                  _                    -> none
              end
          end.
            % thunk
    ```


    let start_child<$a> : fun(proc, Callback.start_arg) -> [$a]option<Callback.child> = external 2 ```
      start_child(SupPid, StartArg) ->
          fun() ->
              case supervisor:start_child(SupPid, [StartArg]) of
                  {ok, ChildPid} when is_pid(ChildPid) -> {some, ChildPid};
                  _                                    -> none
              end
          end.
            % thunk
    ```
  end

end
