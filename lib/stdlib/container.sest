module Stdlib :> sig

  module List : sig
    val map<$a, $b> : fun(fun($a) -> $b, list<$a>) -> list<$b>
    val foldl<$a, $b> : fun(fun($b, $a) -> $b, $b, list<$a>) -> $b
    val foldr<$a, $b> : fun(fun($a, $b) -> $b, $b, list<$a>) -> $b
    val all<$a> : fun(fun($a) -> bool, list<$a>) -> bool
    val any<$a> : fun(fun($a) -> bool, list<$a>) -> bool
    val append<$a> : fun(list<$a>, list<$a>) -> list<$a>
    val reverse<$a> : fun(list<$a>) -> list<$a>
  end

  module GenServer : sig
    signature Behaviour = sig
      type init_arg :: o
      type request :: o  /* temporary; should be a unary GADT */
      type response :: o  /* temporary; should be a unary GADT  */
      type cast_message :: o
      type info :: o
      type state :: o
      val init : fun(init_arg) -> option<state>
      val handle_call<$a> : fun(request, pid<$a>, state) -> (response, state)
      val handle_cast : fun(cast_message, state) -> state
      val handle_info : fun(info, state) -> state
      val terminate : fun(state) -> unit
    end

    module Make : fun(Callback : Behaviour) -> sig
      type proc :: o
      val call<$a> : fun(proc, Callback.request, ?timeout int) -> [$a]Callback.response
      val cast<$a> : fun(proc, Callback.cast_message) -> [$a]unit
      val send_info<$a> : fun(proc, Callback.info) -> [$a]unit
      val start_link<$a> : fun(Callback.init_arg) -> [$a]option<proc>
      val stop<$a> : fun(proc) -> [$a]unit
    end
  end

end = struct
  module List = List
  module GenServer = GenServer
end
