import ServerUtil

module GenServer = struct

  type initialized<$state> = option<$state>

  val init_ok(state) = act
    return(Some(state))

  val init_fail() = act
    return(None)

  type reply<$msg, $response, $state> =
    | ReplyImpl($response, fun() -> [$msg]$state)

  val reply<$msg, $response, $state>(response, state) : [$msg]reply<$msg, $response, $state> = act
    return(ReplyImpl(response, fun() -> act return(state) end))

  val reply_fast<$msg, $response, $state>(response, -rest comp) : [$msg]reply<$msg, $response, $state> = act
    return(ReplyImpl(response, comp))

  type no_reply<$state> =
    | NoReplyImpl($state)

  val no_reply<$msg, $state>(state) : [$msg]no_reply<$state> = act
    return(NoReplyImpl(state))

  signature Behaviour = sig
    type init_arg :: o
    type request :: o  /* temporary; should be a unary GADT */
    type response :: o  /* temporary; should be a unary GADT  */
    type cast_message :: o
    type info :: o
    type state :: o
    val init : fun(init_arg) -> [info]initialized<state>
    val handle_call<$a> : fun(request, pid<$a>, state) -> [info]reply<info, response, state>
    val handle_cast : fun(cast_message, state) -> [info]no_reply<state>
    val handle_info : fun(info, state) -> [info]no_reply<state>
    val terminate : fun(state) -> [info]unit
  end

  module Make = fun(Callback : Behaviour) -> struct
    type request = Callback.request
    type response = Callback.response
    type cast_message = Callback.cast_message
    type proc = pid<Callback.info>

    val init_impl(arg : Callback.init_arg) = act
      Callback.init(arg)

    val init<$a> : $a = external 1 ```
      init(Args) ->
          case ?MODULE:init_impl(Args) of
              {some, State} -> {ok, State};
              none          -> ignore
          end.
    ```

    val handle_call_impl<$a>(req : Callback.request, pid : pid<$a>, state : Callback.state) = act
      Callback.handle_call(req, pid, state)

    val handle_call<$a> : $a = external 3 ```
      handle_call(Msg, From, State0) ->
          {Pid, _} = From,
          case ?MODULE:handle_call_impl(Msg, Pid, State0) of
              {reply_impl, Response, StateF} ->
                  State1 = StateF(),
                  {reply, Response, State1}
          end.
    ```

    val handle_cast_impl(msg : Callback.cast_message, state : Callback.state) = act
      Callback.handle_cast(msg, state)

    val handle_cast<$a> : $a = external 2 ```
      handle_cast(Msg, State0) ->
          case ?MODULE:handle_cast_impl(Msg, State0) of
              {no_reply_impl, State1} ->
                  {noreply, State1}
          end.
    ```

    val handle_info_impl<$a>(info : Callback.info, state : Callback.state) = act
      Callback.handle_info(info, state)

    val handle_info<$a> : $a = external 2 ```
      handle_info(Info, State0) ->
          case handle_info_impl(Info, State0) of
              {no_reply_impl, State1} ->
                  {noreply, State1}
          end.
    ```

    val terminate_impl(state : Callback.state) = act
      Callback.terminate(state)

    val terminate<$a> : $a = external 2 ```
      terminate(_Reason, State) ->
          terminate_impl(State).
    ```

    val call<$a> : fun(proc, request, ?timeout int) -> [$a]response = external 2+ ```
      call(Pid, Msg) ->
          gen_server:call(Pid, Msg).

      call(Pid, Msg, Options) ->
          case maps:find(timeout, Options) of
              {ok, Timeout} -> gen_server:call(Pid, Msg, Timeout);
              error         -> gen_server:call(Pid, Msg)
          end.
    ```

    val cast<$a> : fun(proc, cast_message) -> [$a]unit = external 2 ```
      cast(Pid, Msg) ->
          gen_server:cast(Pid, Msg).
    ```

    val as_pid(proc : proc) =
      proc

    val from_pid(pid : proc) =
      pid

    val start_link<$a> : fun(Callback.init_arg) -> [$a]option<proc> = external 1 ```
      start_link(Args) ->
          Result = gen_server:start_link(?MODULE, Args, []),
          % io:format("debug L('o' )J returns: ~p~n", [Result]),
          case Result of
              {ok, Pid} -> {some, Pid};
              _         -> none
          end.
    ```

    val start_link_name<$a> : fun(Callback.init_arg, -name ServerUtil.name) -> [$a]option<{bool, proc}> = external 2 ```
      start_link_name(Args, NameImpl) ->
          % io:format("debug L('o' )J (~p) GS start_link_name (pre):~n  ~p~n", [?MODULE, Args]),
          Name =
              case NameImpl of
                  {local, Bin}  -> {local, erlang:binary_to_atom(Bin, utf8)};
                  {global, Bin} -> {global, erlang:binary_to_atom(Bin, utf8)}
              end,
          % io:format("debug L('o' )J (~p) GS start_link_name (arg):~n  ~p~n", [?MODULE, Args]),
          StartRet = gen_server:start_link(Name, ?MODULE, Args, []),
          % io:format("debug L('o' )J (~p) GS start_link_name (ret):~n  ~p~n", [?MODULE, StartRet]),
          case StartRet of
              {ok, Pid}                       -> {some, {true, Pid}};
              {error, {already_started, Pid}} -> {some, {false, Pid}};
              _                               -> none
          end.
    ```

    val where_is<$a> : fun(binary) -> [$a]option<proc> = external 1 ```
      where_is(NameBin) ->
          NameAtom = erlang:binary_to_atom(NameBin, utf8),
          case erlang:whereis(NameAtom) of
              Pid when is_pid(Pid) -> {some, Pid};
              _                    -> none
          end.
    ```

    val stop<$a> : fun(proc) -> [$a]unit = external 1 ```
      stop(Pid) ->
          gen_server:stop(Pid).
    ```

    val send_info(pid : proc, info : Callback.info) = act
      send(pid, info)

  end

end
