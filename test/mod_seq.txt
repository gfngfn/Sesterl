
type option<$a> =
  | None
  | Some($a)

signature Decomposable = sig
  type t:: 1
  val empty<$a>: fun() -> t<$a>
  val decompose<$a>: fun(t<$a>) -> option<($a, t<$a>)>
end

module Seq = fun(D: Decomposable) ->
  struct
    type t<$a> = D.t<$a>
    let empty<$a>() = D.empty
    let to_reversed_list<$a>(xs: t<$a>): list<$a> =
      letrec aux(acc, xs) =
        case D.decompose(xs) of
        | None            -> acc
        | Some((x, tail)) -> aux(x :: acc, tail)
        end
      in
      aux([], xs)
  end

module ListD = struct
  type t<$a> = list<$a>
  let empty() = []
  let decompose(xs) =
    case xs of
    | []        -> None
    | x :: tail -> Some((x, xs))
    end
end

module ListSeq = Seq(ListD)
