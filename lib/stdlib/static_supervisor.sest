require SupervisorCommon

module StaticSupervisor = struct

  include SupervisorCommon

  type child_spec<$id> = {
    id       : $id,
    start    : frozen<unit, child_proc>,
    restart  : restart,
    shutdown : shutdown,
    typ      : worker,
  }

  let make_child_spec<$id>(
    -id       id : $id,
    -start    start,
    ?restart  restart = Permanent,
    ?shutdown shutdown_opt,
    ?type     typ = Worker,
  ) : child_spec<$id> =
    let shutdown =
      case {shutdown_opt, typ} of
      | {Some(shutdown), _} -> shutdown
      | {None, Worker}      -> Timeout(5000)
      | {None, Supervisor}  -> Infinity
      end
    in
    {
      id       = id,
      start    = start,
      restart  = restart,
      shutdown = shutdown,
      typ      = typ,
    }

  type strategy = OneForAll | OneForOne | RestForOne

  type sup_flags = {
    strategy  : strategy,
    intensity : int,
    period    : int,
  }

  let make_sup_flags(
    ?strategy  strategy  = OneForOne,
    ?intensity intensity = 1,
    ?period    period    = 5,
  ) : sup_flags =
    { strategy = strategy, intensity = intensity, period = period }

  type initialized<$id> = option<{sup_flags, list<child_spec<$id>>}>

  let init_ok<$msg, $id>(sup_flags : sup_flags, child_specs : list<child_spec<$id>>) : [$msg]initialized<$id> =
    return(Some({sup_flags, child_specs}))

  let init_fail() =
    return(None)

  signature Behaviour = sig
    type child_id :: o
    type init_arg :: o
    type info :: o
    val init : fun(init_arg) -> [info]initialized<child_id>
  end

  module Make = fun(Callback : Behaviour) -> struct

    type proc = ProcDummy

    let init_impl(args) =
      Callback.init(args)

    let init<$a> : $a = external 1 ```
      init(Args) ->
          InitF = init_impl(Args),
          Ret =
          case InitF() of
              none ->
                  ignore;

              {some, {SupFlags, ChildSpecsImpl}} ->
                  ChildSpecs =
                      lists:map(
                          fun(ChildSpecImpl) ->
                              #{
                                  id       := ChildId,
                                  start    := StartFunc,
                                  restart  := Restart,
                                  shutdown := ShutdownImpl,
                                  typ      := Worker
                              } = ChildSpecImpl,
                              Shutdown =
                                  case ShutdownImpl of
                                      brutal_kill  -> brutal_kill;
                                      {timeout, N} -> max(N, 0);
                                      infinity     -> infinity
                                  end,
                              #{
                                  id       => ChildId,
                                  start    => StartFunc,
                                  restart  => Restart,
                                  shutdown => Shutdown,
                                  type     => Worker
                              }
                          end,
                          ChildSpecsImpl),
                  {ok, {SupFlags, ChildSpecs}}
          end,
          io:format("debug L('o' )J (~p) St init:~n  ~p~n", [?MODULE, Ret]),
          Ret.
    ```

    let as_pid : fun(proc) -> pid<Callback.info> = external 1 ```
      as_pid(Pid) -> Pid.
    ```

    let start_link<$a> : fun(Callback.init_arg) -> [$a]option<proc> = external 1 ```
      start_link(Args) ->
          fun() ->
              io:format("debug L('o' )J (~p) start_link (arg):~n  ~p~n", [?MODULE, Args]),
              StartRet = supervisor:start_link(?MODULE, Args),
              Ret =
              case StartRet of
                  {ok, Pid} -> {some, Pid};
                  _         -> none
              end,
              io:format("debug L('o' )J (~p) start_link (ret):~n  ~p~n", [?MODULE, StartRet]),
              Ret
          end.
            % thunk
    ```
  end

end
