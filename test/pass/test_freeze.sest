module TestFreeze = struct

  module Sub = struct
    val add(x, y) = x + y
    val rec foldl(f, i, l) =
      case l of
      | []      -> i
      | x :: xs -> foldl(f, f(i, x), xs)
      end
  end

  val negate(n) = 0 - n

  val partial(x) : frozen<{int}, int> =
    freeze Sub.add(x, _)

  val full(y) : frozen<unit, int> =
    let p = partial(42) in
    freeze (p) with (y)

  val partial1() : frozen<{int, list<int>}, int> =
    freeze Sub.foldl(Sub.add, _, _)

  val partial2() : frozen<{list<int>}, int> =
    freeze (partial1()) with (0, _)

  val impl() : list<frozen<unit, int>> =
    [
      freeze Sub.add(42, 57),
      freeze negate(100),
      freeze (partial2()) with ([3, 1, 4, 5, 9, 2]),
    ]

  val main<$a> : fun($a) -> unit = external 1 ```
main(_) ->
    List = impl(),
    lists:foreach(
        fun({M, F, Args}) ->
            Result = apply(M, F, Args),
            io:format("~p~n", [Result])
        end,
        List).
  ```
end
