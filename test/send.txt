
type bintree($a) =
  | Node($a, bintree($a), bintree($a))
  | Empty

let leaf(x) =
  Node(x, Empty, Empty)

let bintree_of_int(n) =
  letrec aux(top, n) =
  if n <= 0 then
    Empty
  else
    let n1 = (n - 1) / 2 in
    let n2 = (n - 1) - n1 in
    let tr1 = aux(top + 1, n1) in
    let tr2 = aux(top + n1 + 1, n2) in
    Node(top, tr1, tr2)
  in
  aux(1, n)

let reverse_list(xs) =
  letrec aux(rev, xs) =
    case xs of
    | []        -> rev
    | x :: tail -> aux(x :: rev, tail)
    end
  in
  aux([], xs)

letrec wait_all(n) =
  if n <= 0 then
    return(())
  else
    receive
    | (from, x) ->
        let _ = print_debug((from, x, n)) in
        wait_all(n - 1)
    end

letrec aux(acc, n) =
  if n <= 0 then
    return(reverse_list(acc))
  else
    do parent <- self in
    do pid <-
      spawn(
        do me <- self in
        send(parent, (me, bintree_of_int(n)))
      )
    in
    aux(pid :: acc, n - 1)

let main() =
  let m = 10 in
  do pids <- aux([], m) in
  let _ = print_debug(pids) in
  wait_all(m)
