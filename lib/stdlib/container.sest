module Stdlib :> sig

  module List : sig
    val map<$a, $b> : fun(fun($a) -> $b, list<$a>) -> list<$b>
    val foldl<$a, $b> : fun(fun($b, $a) -> $b, $b, list<$a>) -> $b
    val foldr<$a, $b> : fun(fun($a, $b) -> $b, $b, list<$a>) -> $b
    val all<$a> : fun(fun($a) -> bool, list<$a>) -> bool
    val any<$a> : fun(fun($a) -> bool, list<$a>) -> bool
    val append<$a> : fun(list<$a>, list<$a>) -> list<$a>
    val reverse<$a> : fun(list<$a>) -> list<$a>
  end

  module GenServer : sig

    type initialized :: (o) -> o

    val init_ok<$msg, $state> : fun($state) -> [$msg]initialized<$state>

    val init_fail<$msg, $state> : fun() -> [$msg]initialized<$state>

    type reply :: (o, o, o) -> o

    val reply<$msg, $response, $state> :
      fun($response, $state) -> [$msg]reply<$msg, $response, $state>

    val reply_fast<$msg, $response, $state> :
      fun($response, -rest [$msg]$state) -> [$msg]reply<$msg, $response, $state>

    type no_reply :: (o) -> o

    val no_reply<$msg, $state> : fun($state) -> [$msg]no_reply<$state>

    signature Behaviour = sig
      type init_arg :: o
      type request :: o  /* temporary; should be a unary GADT */
      type response :: o  /* temporary; should be a unary GADT  */
      type cast_message :: o
      type info :: o
      type state :: o
      val init : fun(init_arg) -> [info]initialized<state>
      val handle_call<$a> : fun(request, pid<$a>, state) -> [info]reply<info, response, state>
      val handle_cast : fun(cast_message, state) -> [info]no_reply<state>
      val handle_info : fun(info, state) -> [info]no_reply<state>
      val terminate : fun(state) -> [info]unit
    end

    module Make : fun(Callback : Behaviour) -> sig
      type proc :: o
      val call<$a> : fun(proc, Callback.request, ?timeout int) -> [$a]Callback.response
      val cast<$a> : fun(proc, Callback.cast_message) -> [$a]unit
      val send_info<$a> : fun(proc, Callback.info) -> [$a]unit
      val start_link<$a> : fun(Callback.init_arg) -> [$a]option<proc>
      val stop<$a> : fun(proc) -> [$a]unit
    end
  end

  module Supervisor : sig
    type child_proc :: o
    val make_child_proc<$a, $b> : fun([$b]option<pid<$a>>) -> child_proc
    type restart = Permanent | Transient | Temporary
    type shutdown = BrutalKill | Timeout(int) | Infinity
    type worker = Worker | Supervisor
    type child_spec :: (o, o) -> o
    val make_child_spec<$id, $arg> :
      fun(
        -id       $id,
        -start    frozen<{$arg}, child_proc>,
        ?restart  restart,
        ?shutdown shutdown,
        ?type     worker,
      ) -> child_spec<$id, $arg>

    module Static : sig
      type strategy = OneForAll | OneForOne | RestForOne
      type sup_flags :: o
      val make_sup_flags : fun(?strategy strategy, ?intensity int, ?period int) -> sup_flags
      type initialized :: (o) -> o
      val init_ok<$msg, $id> : fun(sup_flags, list<child_spec<$id, unit>>) -> [$msg]initialized<$id>
      val init_fail<$msg, $id> : fun() -> [$msg]initialized<$id>

      signature Behaviour = sig
        type child_id :: o
        type init_arg :: o
        type info :: o
        val init : fun(init_arg) -> [info]initialized<child_id>
      end

      module Make : fun(Callback : Behaviour) -> sig
        type proc :: o
        val as_pid : fun(proc) -> pid<Callback.info>
        val start_link<$a> : fun(Callback.init_arg) -> [$a]option<proc>
      end
    end

    module Dynamic : sig
      type sup_flags :: o
      val make_sup_flags : fun(?intensity int, ?period int) -> sup_flags
      type initialized :: (o, o) -> o
      val init_ok<$msg, $id, $arg> : fun(sup_flags, child_spec<$id, $arg>) -> [$msg]initialized<$id, $arg>
      val init_fail<$msg, $id, $arg> : fun() -> [$msg]initialized<$id, $arg>

      signature Behaviour = sig
        type child_id :: o
        type start_arg :: o
        type info :: o
        val init : fun() -> [info]initialized<child_id, start_arg>
      end

      module Make : fun(Callback : Behaviour) -> sig
        type proc :: o
        val as_pid : fun(proc) -> pid<Callback.info>
        val start_link<$a> : fun(Callback.start_arg) -> [$a]option<proc>
      end
    end
  end

end = struct
  module List = List
  module GenServer = GenServer
  module Supervisor = Supervisor
end
