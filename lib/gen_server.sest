module Prim = struct

  module GenServer = struct

    signature Behaviour = sig

      type init_arg :: 0

      type request :: 0
        /* temporary; should be a unary GADT */

      type response :: 0
        /* temporary; should be a unary GADT  */

      type cast_message :: 0

      type state :: 0

      val init : fun(init_arg) -> state

      val handle_call<$a> : fun(request, pid<$a>, state) -> (response, state)

      val handle_cast : fun(cast_message, state) -> state

    end

    module Make = fun(Callback : Behaviour) -> struct

      type request = Callback.request

      type response = Callback.response

      type cast_message = Callback.cast_message

      type gen_server = unit

      type proc = pid<gen_server>

      type start_result =
        | StartOk(proc)

      let init_impl(arg : Callback.init_arg) =
        Callback.init(arg)

      let init<$a> : $a = external 1 ```
        init(Args) ->
            State = ?MODULE:init_impl(Args),
            {ok, State}.
      ```

      let handle_call_impl<$a>(req : Callback.request, pid : pid<$a>, state : Callback.state) =
        Callback.handle_call(req, pid, state)

      let handle_call<$a> : $a = external 3 ```
        handle_call(Msg, From, State0) ->
            {Pid, _} = From,
            {Response, State1} = ?MODULE:handle_call_impl(Msg, Pid, State0),
            {reply, Response, State1}.
      ```

      let handle_cast_impl(msg : Callback.cast_message, state : Callback.state) =
        Callback.handle_cast(msg, state)

      let handle_cast<$a> : $a = external 2 ```
        handle_cast(Msg, State0) ->
            State1 = ?MODULE:handle_cast_impl(Msg, State0),
            {noreply, State1}.
      ```

      let call<$a> : fun(proc, request) -> [$a]response = external 2 ```
        call(Pid, Msg) ->
            fun() -> gen_server:call(Pid, Msg) end.
      ```

      let cast<$a> : fun(proc, cast_message) -> [$a]unit = external 2 ```
        cast(Pid, Msg) ->
            fun() -> gen_server:cast(Pid, Msg) end.
      ```

      let start_link<$a> : fun(Callback.init_arg) -> [$a]start_result = external 1 ```
        start_link(Args) ->
            case gen_server:start_link(?MODULE, Args, []) of
                {ok, Pid}       -> {start_ok, Pid};
                ignore          -> erlang:error(unsupported_ignore);
                {error, Reason} -> erlang:error(Reason)
            end.
      ```

    end

  end

  module Example = struct

    module C = struct

      type init_arg =
        (int, binary)

      type request =
        | GetNumber
        | GetName

      type response =
        | Number(int)
        | Name(binary)

      type cast_message =
        | SetNumber(int)

      type state =
        (int, binary)

      let init(state) =
        state

      let handle_call(req, pid, state) =
        let (n, s) = state in
        case req of
        | GetNumber -> (Number(n), state)
        | GetName   -> (Name(s), state)
        end

     let handle_cast(msg, state) =
       let (_, s) = state in
       case msg of
       | SetNumber(m) -> (m, s)
       end

    end

    include GenServer.Make(C)

  end

  module Main = struct

    let call(pid, msg) =
      Example.call(pid, msg)

  end

end
