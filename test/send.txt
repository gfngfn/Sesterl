
type bintree[$a] =
  | Node($a, bintree[$a], bintree[$a])
  | Empty

let bintree_of_int(n: int): bintree[int] =
  letrec aux(top, n) =
  if n <= 0 then
    Empty
  else
    let n1 = (n - 1) / 2 in
    let n2 = (n - 1) - n1 in
    let tr1 = aux(top + 1, n1) in
    let tr2 = aux(top + n1 + 1, n2) in
    Node(top, tr1, tr2)
  in
  aux(1, n)

let reverse_list[$a](xs: list[$a]): list[$a] =
  letrec aux(rev, xs) =
    case xs of
    | []        -> rev
    | x :: tail -> aux(x :: rev, tail)
    end
  in
  aux([], xs)

letrec wait_all(n: int) =
  if n <= 0 then
    return(())
  else
    receive
    | msg ->
        let _ = print_debug(msg) in
        wait_all(n - 1)
    end
/*
letrec spawn_all(acc, n: int) =
  if n <= 0 then
    return(reverse_list(acc))
  else
    do parent <- self in
    do pid <- spawn(
      do me <- self in
      send(parent, (me, bintree_of_int(n)))
    ) in
    spawn_all(pid :: acc, n - 1)

let main() =
  let m = 10 in
  do pids <- spawn_all([], m) in
  let _ = print_debug(pids) in
  wait_all(m)
*/
