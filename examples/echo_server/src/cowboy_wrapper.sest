module CowboyWrapper :> sig
  type req :: o
  type dispatch_table :: o
  type listener :: o
  type init_result :: (o) -> o
  type header = Stdlib.RawMap.t<binary, binary>
  val make_dispatch_table<$msg, $state> : fun(frozen<{req, $state}, $msg, init_result<$state>>, list<{binary, $state}>) -> option<dispatch_table>
  val start_clear<$eff> : fun(-name binary, -port int, -dispatch dispatch_table) -> [$eff]option<listener>
  val parse_qs : fun(req) -> Stdlib.RawMap.t<binary, option<binary>>
  val reply<$a> : fun(int, header, binary, req) -> [$a]req
  val init_ok<$a, $state> : fun(req, $state) -> [$a]init_result<$state>
  val stop_listener<$a> : fun(binary) -> [$a]unit
end = struct

  type req = ReqDummy
  type dispatch_table = DispatchTableDummy
  type listener = ListenerDummy
  type init_result<$state> = InitResultDummy
  type header = Stdlib.RawMap.t<binary, binary>

  val make_dispatch_table<$msg, $state> : fun(frozen<{req, $state}, $msg, init_result<$state>>, list<{binary, $state}>) -> option<dispatch_table>
  = external 2 ```
    make_dispatch_table(MFArgs, Routes) ->
        try
            {M, init, []} = MFArgs,
            Dispatch =
                cowboy_router:compile([
                    {'_', lists:map(fun({Path, InitialState}) -> {Path, M, InitialState} end, Routes)}
                ]),
            {some, Dispatch}
        catch
            _:_ ->
                none
        end.
  ```

  val start_clear<$eff> : fun(-dispatch dispatch_table, -name binary, -port int) -> [$eff]option<listener>
  = external 3 ```
    start_clear(Dispatch, NameBin, Port) ->
    % label parameters are in alphabetical order
        Result =
            cowboy:start_clear(
                erlang:binary_to_atom(NameBin),
                [{port, Port}],
                #{env => #{dispatch => Dispatch}}
            ),
        case Result of
            {ok, ListenerPid} -> {some, ListenerPid};
            {error, _}        -> none
        end.
  ```

  val parse_qs : fun(req) -> Stdlib.RawMap.t<binary, option<binary>> = external 1 ```
    parse_qs(Req) ->
        Assoc = cowboy_req:parse_qs(Req),
        lists:foldl(
            fun({KeyBin, Value}, Map) ->
                case Value of
                    true     -> Map#{KeyBin => none};
                    ValueBin -> Map#{KeyBin => {some, ValueBin}}
                end
            end,
            #{},
            Assoc).
  ```

  val reply<$a> : fun(int, header, binary, req) -> [$a]req = external 4 ```
    reply(StatusCode, Header, Body, Req) ->
        cowboy_req:reply(StatusCode, Header, Body, Req).
  ```

  val init_ok<$a, $state> : fun(req, $state) -> [$a]init_result<$state> = external 2 ```
    init_ok(Req, State) ->
        {ok, Req, State}.
  ```

  val stop_listener<$a> : fun(binary) -> [$a]unit = external 1 ```
    stop_listener(NameBin) ->
        _ = cowboy:stop_listener(erlang:binary_to_atom(NameBin)),
        ok.
  ```

end
